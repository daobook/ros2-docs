# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-16 10:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../source/Concepts/About-Executors.rst:4
msgid "Executors"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:7
msgid "Table of Contents"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:10
msgid "Overview"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:12
msgid ""
"Execution management in ROS 2 is explicated by the concept of Executors. "
"An Executor uses one or more threads of the underlying operating system "
"to invoke the callbacks of subscriptions, timers, service servers, action"
" servers, etc. on incoming messages and events. The explicit Executor "
"class (in `executor.hpp "
"<https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp>`_"
" in rclcpp, in `executors.py "
"<https://github.com/ros2/rclpy/blob/master/rclpy/rclpy/executors.py>`_ in"
" rclpy, or in `executor.h "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_"
" in rclc) provides more control over execution management than the spin "
"mechanism in ROS 1, although the basic API is very similar."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:16
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:19
msgid "Basic use"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:21
msgid ""
"In the simplest case, the main thread is used for processing the incoming"
" messages and events of a Node by calling ``rclcpp::spin(..)`` as "
"follows:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:42
msgid ""
"The call to ``spin(node)`` basically expands to an instatiation and "
"invokation of the Single-Threaded Executor, which is the simplest "
"Executor:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:50
msgid ""
"By invoking ``spin()`` of the Executor instance, the current thread "
"starts querying the rcl and middleware layers for incoming messages and "
"other events and calls the corresponding callback functions until the "
"node shuts down. In order not to counteract the QoS settings of the "
"middleware, an incoming message is not stored in a queue on the Client "
"Library layer but kept in the middleware until it is taken for processing"
" by a callback function. (This is a crucial difference to ROS 1.) A *wait"
" set* is used to inform the Executor about available messages on the "
"middleware layer, with one binary flag per queue."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:57
msgid ""
"The Single-Threaded Executor is also used by the container process for "
":doc:`components <./About-Composition>`, i.e. in all cases where nodes "
"are created and executed without an explicit main function."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:60
msgid "Types of Executors"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:62
msgid ""
"Currently, rclcpp provides three Executor types, derived from a shared "
"parent class:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:78
msgid ""
"The *Multi-Threaded Executor* creates a configurable number of threads to"
" allow for processing multiple messages or events in parallel. The "
"*Static Single-Threaded Executor* optimizes the runtime costs for "
"scanning the structure of a node in terms of subscriptions, timers, "
"service servers, action servers, etc. It performs this scan only once "
"when the node is added, while the other two executors regularly scan for "
"such changes. Therefore, the Static Single-Threaded Executor should be "
"used only with nodes that create all subscriptions, timers, etc. during "
"initialization."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:83
msgid ""
"All three executors can be used with multiple nodes by calling "
"``add_node(..)`` for each node."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:97
msgid ""
"In the above example, the one thread of a Static Single-Threaded Executor"
" is used to serve three nodes together. In case of a Multi-Threaded "
"Executor, the actual parallelism depends on the callback groups."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:101
msgid "Callback groups"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:103
msgid ""
"The rclcpp allows organizing the callbacks of a node in groups. Such a "
"*callback group* can be created by the ``create_callback_group`` function"
" of the Node class. Then, this callback group can be specified when "
"creating a subscription, timer, etc. - for example by the subscription "
"options:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:117
msgid ""
"All subscriptions, timers, etc. that are created without the indication "
"of a callback group are assigned to the *default callback group*. The "
"default callback group can be queried via "
"``NodeBaseInterface::get_default_callback_group()``."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:120
msgid ""
"There are two types of callback groups, where the type has to be "
"specified at instantiation time:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:122
msgid ""
"*Mutually exclusive:* Callbacks of this group must not be executed in "
"parallel."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:123
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:125
msgid ""
"Callbacks of different callback groups may always be executed in "
"parallel. The Multi-Threaded Executor uses its threads as a pool to "
"process a many callbacks as possible in parallel according to these "
"conditions."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:128
msgid ""
"Since Galactic, the interface of the Executor base class has been refined"
" by a new function ``add_callback_group(..)``. This allows distributing "
"callback groups to different Executors. By configuring the underlying "
"threads using the operating system scheduler, specific callbacks can be "
"prioritized over other callbacks. For example, the subscriptions and "
"timers of a control loop can be prioritized over all other subscriptions "
"and standard services of a node. The `examples_rclcpp_cbg_executor "
"package "
"<https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor>`_"
" provides a demo of this mechanism."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:135
msgid "Scheduling semantics"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:137
msgid ""
"If the processing time of the callbacks is shorter than the period with "
"which messages and events occur, the Executor basically processes them in"
" FIFO order. However, if the processing time of some callbacks is longer,"
" messages and events will be queued on the lower layers of the stack. The"
" wait set mechanism reports only very little information about these "
"queues to the Executor. In detail, it only reports whether there are any "
"messages for a certain topic or not. The Executor uses this information "
"to process the messages (including services and actions) in a round-robin"
" fashion - but not in FIFO order. In addition, it prioritizes all timer "
"events over the messages. The following flow diagram visualizes this "
"scheduling semantics."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:147
msgid ""
"This semantics was first described in a `paper by Casini et al. at ECRTS "
"2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:150
msgid "Outlook"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:152
msgid ""
"While the three Executors of rclcpp work well for most applications there"
" are some issues that make them not suitable for real-time applications, "
"which require well-defined execution times, determinism, and custom "
"control over the execution order. Here is a summary of some of these "
"issues:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:155
msgid ""
"Complex and mixed scheduling semantics. Ideally you want well defined "
"scheduling semantics to perform a formal timing analysis."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:157
msgid ""
"Callbacks may suffer from priority inversion. Higher priority callbacks "
"may be blocked by lower priority callbacks."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:159
msgid "No explicit control over the callbacks execution order."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:160
msgid "No built-in control over triggering for specific topics."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:162
msgid ""
"Additionally, the executor overhead in terms of CPU and memory usage is "
"considerable. The Static Single-Threaded Executor reduces this overhead "
"greatly but it might be not enough for some applications."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:165
msgid "These issues have been partially addressed by the following developments:"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:167
msgid ""
"`rclcpp WaitSet "
"<https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/wait_set.hpp>`_:"
" The ``WaitSet`` class of rclcpp allows waiting directly on "
"subscriptions, timers, service servers, action servers, etc. instead of "
"using an Executor. It can be used to implement deterministic, user-"
"defined processing sequences, possibly processing multiple messages from "
"different subscriptions together. The `examples_rclcpp_wait_set package "
"<https://github.com/ros2/examples/tree/master/rclcpp/wait_set>`_ provides"
" several examples for the use of this user-level wait set mechanism."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:170
msgid ""
"`rclc Executor "
"<https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_:"
" This Executor from the C Client Library *rclc* developed for micro-ROS "
"gives the user fine-grained control over the execution order of callbacks"
" and allows for custom trigger conditions to activate callbacks. "
"Furthermore, it implements ideas of the Logical Execution Time (LET) "
"semantics."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:174
msgid "Further information"
msgstr ""

#: ../../source/Concepts/About-Executors.rst:176
msgid ""
"Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-"
"time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at "
"ROS World 2021. Virtual event. 19 October 2021."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:177
msgid ""
"Ralph Lange: `\"Advanced Execution Management with ROS 2\" "
"<https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial "
"Conference. Virtual event. 16 December 2020."
msgstr ""

#: ../../source/Concepts/About-Executors.rst:178
msgid ""
"Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: "
"`“Response-Time Analysis of ROS 2 Processing Chains under Reservation-"
"Based Scheduling” "
"<https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-"
"ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July "
"2019."
msgstr ""

